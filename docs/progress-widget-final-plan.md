# Финальный план правок для виджета прогресса

## 1) Стабильное выравнивание кружка по кнопке «Структура курса»

**Идея.** Не полагаться на одноразовый расчёт `--pw-float-left`/`--pw-float-bottom`, который сейчас прерывается, если `dock-handle` временно вне раскладки. Вместо этого:

* Делать первый расчёт после `requestAnimationFrame`/`IntersectionObserver` как только `menu-handle` появился в потоке.
* Хранить последнюю валидную позицию и использовать её как fallback, даже если при следующем вызове `offsetParent === null`.
* Подписаться на `ResizeObserver` для `menu-handle` и на `window resize` — обновлять переменные, когда ручка меняет размеры/позицию.
* В крайнем случае брать координаты `.menu-handle` (если `dock-handle` отсутствует), чтобы не падать на `left: 0`.

**Почему безопасно.**
* Логика ограничена mobile (`body.dataset.mode === 'mobile'` уже есть в `updateProgressWidgetFloatingAnchors`).
* Мы не меняем базовую вёрстку — только заполняем CSS‑переменные устойчивее.
* Подписки чистятся вместе с текущим `registerLifecycleDisposer`, поэтому другие режимы (desktop/tablet) не затрагиваются.

## 2) Кнопка «Далее/Полный доступ» остаётся закреплённой даже после глубокого скролла

**Идея.** Сделать прогресс‑виджет одноразово монтируемым и не удалять DOM при деактивации ленивой фичи.

* В `activateProgressWidgetFeature()` после первой инициализации не удалять `#pw-root` и слот; вместо полного cleanup — только отписывать слушатели и останавливать анимации.
* Перенести `pw-slot` за пределы ленивой панели (или клонировать в `body`) для mobile, чтобы `IntersectionObserver` на `.panel` не управлял видимостью кнопки.
* Убедиться, что lifecycle‑cleanup (pagehide/beforeunload) по‑прежнему удаляет элемент, чтобы не ломать повторные заходы.

**Почему безопасно.**
* Виджет остаётся фиксированным и не зависит от видимости панели, но все хуки диспозятся — нет утечек слушателей.
* Desktop/таблет получают ту же логику, но там виджет и так sticky; поведение не меняется, кроме предотвращения удаления DOM после ленивого «выгружения».
* Перенос слота в `body` делается условно для mobile, поэтому основной макет панели не затрагиваем.

## 3) Минимальные риски для других режимов и A/B

* Все новые ветки поведение ограничивают `body.dataset.mode === 'mobile'` либо `controlsWindowScroll`.
* Fallback‑координаты сохраняются в JS, но не меняют CSS для desktop, где `updateLayoutMetrics` уже сбрасывает `--pw-float-*`.
* Одноразовый монтаж убирает гонки с ленивой выгрузкой, но lifecycle‑диспозер по `pagehide/beforeunload` сохраняется, поэтому нет «вечного» элемента при смене страниц.

## Что менять точечно

* `updateProgressWidgetFloatingAnchors()` — убрать ранний выход при `offsetParent === null`, добавить кеш последнего `left/bottom`, подписку на `ResizeObserver` и fallback к `.menu-handle`.
* `activateProgressWidgetFeature()`/`initProgressWidget()` — разделить cleanup: отделить удаление DOM от снятия слушателей; при ленивой деактивации не трогать DOM, удалять только на полный lifecycle‑teardown.
* `template-full.html` (mobile) — при необходимости задать контейнер `pw-slot` вне `.panel`, но в пределах `main`, чтобы не ломать десктопную сетку.
